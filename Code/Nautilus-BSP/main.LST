C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE main.c BROWSE INCDIR(.\inc) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "STC15F2K60S2.H" //±?????
   2          #include "sys.H"      //±?????
   3          #include "displayer.H"
   4          #include "beep.H"
   5          #include "music.H"
   6          #include "key.H"
   7          #include "stepmotor.H"
   8          #include "vib.H"
   9          #include "hall.H"
  10          #include "adc.H"
  11          #include "uart1.h"
  12          #include "uart2.h"
  13          #include "IR.h"
  14          #include "DS1302.h"
  15          #include "M24C02.h"
  16          #include "FM_Radio.h"
  17          #include "EXT.h"
  18          #include "stepmotor.h"
  19          
  20          code unsigned long SysClock = 11059200; // ±??????¨???????¤×÷?±??????(Hz)?????§±????????????????¤
             -×÷?????¨?????±????????????
  21          #ifdef _displayer_H_          // ???????é?????±±??????¨??????????????±í????‘?????????????????
  22          code char decode_table[] = {
  23            // 数字 0-9
  24            0x3F, // 0: 00111111 (a,b,c,d,e,f亮)
  25            0x06, // 1: 00000110 (b,c亮)
  26            0x5B, // 2: 01011011 (a,b,g,e,d亮)
  27            0x4F, // 3: 01001111 (a,b,g,c,d亮)
  28            0x66, // 4: 01100110 (f,g,b,c亮)
  29            0x6D, // 5: 01101101 (a,f,g,c,d亮)
  30            0x7D, // 6: 01111101 (a,f,g,c,d,e亮)
  31            0x07, // 7: 00000111 (a,b,c亮)
  32            0x7F, // 8: 01111111 (全亮)
  33            0x6F, // 9: 01101111 (a,b,c,d,f,g亮)
  34          
  35            // 大写字母 A-Z（常用可显示的字母）
  36            0x77, // A (10): 01110111 (a,b,c,f,g亮)
  37            0x7C, // B (11): 01111100 (f,g,c,d,e亮，类似8少a)
  38            0x39, // C (12): 00111001 (a,f,e,d亮)
  39            0x5E, // D (13): 01011110 (b,c,d,e,g亮)
  40            0x79, // E (14): 01111001 (a,f,e,d,g亮)
  41            0x71, // F (15): 01110001 (a,f,e,g亮)
  42            0x3D, // G (16): 00111101 (a,f,g,c,d,e亮，6多g)
  43            0x76, // H (17): 01110110 (f,g,b,c,e亮)
  44            0x06, // I (18): 00000110 (同1)
  45            0x1E, // J (19): 00011110 (b,c,d,e亮)
  46            0x75, // K (20): 01110101 (f,g,b,c,e亮，类似H但e段不同)
  47            0x38, // L (21): 00111000 (f,e,d亮)
  48            0x15, // M (22): 00010101 (a,b,c,f,e亮，自定义简化版)
  49            0x54, // N (23): 01010100 (a,b,c,f,g亮，简化版)
  50            0x5C, // O (24): 01011100 (a,b,c,d,e亮，类似0少g)
  51            0x73, // P (25): 01110011 (a,b,f,g,e亮)
  52            0x6B, // Q (26): 01100111 (a,b,c,d,f,g亮，9多e)
  53            0x50, // R (27): 01010000 (a,b,f,g亮，简化版)
  54            0x6D, // S (28): 01101101 (同5)
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 2   

  55            0x78, // T (29): 01111000 (f,g,e亮)
  56            0x3E, // U (30): 00111110 (b,c,d,e,f亮，类似0少a)
  57            0x1C, // V (31): 00011100 (b,c,d,e亮，简化版)
  58            0x2A, // W (32): 00101010 (自定义简化版，显示为双V)
  59            0x76, // X (33): 01110110 (同H)
  60            0x6E, // Y (34): 01101110 (b,c,d,f,g亮)
  61            0x5B, // Z (35): 01011011 (同2)
  62          
  63            // 小写字母（常用）
  64            0x5F, // a (36): 01011111 (类似9少b)
  65            0x7C, // b (37): 01111100 (同大写B)
  66            0x58, // c (38): 01011000 (f,e,d,g亮)
  67            0x5E, // d (39): 01011110 (同大写D)
  68            0x7B, // e (40): 01111011 (a,f,g,e,d亮，E多g)
  69            0x71, // f (41): 01110001 (同大写F)
  70          
  71            // 符号
  72            0x40, // - (42): 01000000 (g亮)
  73            0x80, // . (43): 10000000 (小数点亮)
  74            0x00, // 空格 (44): 00000000 (全灭)
  75            0x63  // = (45): 01100011 (g和d段亮)
  76          };
  77          #endif
  78          code char pokemon_get_DAZE[] = {
  79            0x00, 0x08, 0x25, 0x04, 0x27, 0x04, 0x31, 0x04, 0x27, 0x04, 0x31, 0x04, 0x32, 0x04, 0x33, 0x20,
  80            0x00, 0x08, 0x26, 0x08, 0x31, 0x08, 0x33, 0x08, 0x32, 0x08, 0x31, 0x08, 0x27, 0x08, 0x25, 0x08,
  81            0x00, 0x08, 0x26, 0x04, 0x27, 0x04, 0x31, 0x04, 0x27, 0x04, 0x31, 0x04, 0x32, 0x04, 0x33, 0x20,
  82            0x00, 0x08, 0x26, 0x08, 0x31, 0x04, 0x33, 0x08, 0x35, 0x04, 0x00, 0x10, 0x00, 0x08, 0x26, 0x08,
  83          
  84            0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04,
  85            0x26, 0x08, 0x31, 0x08, 0x31, 0x04, 0x32, 0x08, 0x27, 0x14, 0x00, 0x08, 0x26, 0x04, 0x26, 0x04,
  86            0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x26, 0x04, 0x26, 0x04,
  87            0x33, 0x08, 0x33, 0x08, 0x32, 0x04, 0x31, 0x08, 0x27, 0x24,
  88            0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04, 0x31, 0x04, 0x26, 0x04,
  89            0x26, 0x08, 0x31, 0x08, 0x31, 0x04, 0x32, 0x08, 0x27, 0x14, 0x00, 0x08, 0x26, 0x04, 0x26, 0x04,
  90            0x31, 0x08, 0x26, 0x08, 0x33, 0x08, 0x32, 0x08, 0x31, 0x04, 0x26, 0x0c, 0x00, 0x08, 0x26, 0x04, 0x26, 0x0
             -4,
  91            0x31, 0x08, 0x26, 0x18, 0x36, 0x08, 0x35, 0x08, 0x33, 0x08, 0x32, 0x08,
  92            0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08,
  93            0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x32, 0x08,
  94            0x31, 0x08, 0x32, 0x08, 0x31, 0x08, 0x31, 0x08, 0x00, 0x08, 0x00, 0x10,
  95          
  96            0x33, 0x04, 0x33, 0x04, 0x33, 0x08, 0x33, 0x0c, 0x33, 0x14, 0x31, 0x04, 0x31, 0x04, 0x31, 0x04,
  97            0x33, 0x04,
  98            0x32, 0x08, 0x35, 0x38,
  99            0x33, 0x04, 0x33, 0x04, 0x33, 0x08, 0x33, 0x0c, 0x33, 0x14, 0x31, 0x04, 0x31, 0x04, 0x31, 0x04,
 100            0x33, 0x04,
 101            0x32, 0x30, 0x00, 0x08, 0x32, 0x08,
 102          
 103            0x26, 0x08, 0x26, 0x08, 0x26, 0x08, 0x32, 0x08, 0x28, 0x08, 0x27, 0x18,
 104          
 105            0x00, 0x10};
 106          struct_DS1302_RTC initTime = {
 107            0x00,
 108            0x12,
 109            0x16,
 110            0x18,
 111            0x09,
 112            0x04,
 113            0x25};
 114          struct_DS1302_RTC currentTime;
 115          #define RECEIVE_LEN 5
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 3   

 116          int count = 0;
 117          // Beep控制
 118          int interp = 1;
 119          int a = 0;
 120          // LED控制
 121          int LEDmode = 1;
 122          int LEDchange = 1;
 123          unsigned char led_val = 0x02;
 124          int led_flow_reverse = 1;
 125          // 串口控制
 126          char data_recieved[RECEIVE_LEN];
 127          char matched_data[] = {0xaa, 0x55};
 128          char uart_data[20];
 129          void myUart2_callback()
 130          {
 131   1        char flag = data_recieved[2];
 132   1        char menu_select = data_recieved[3];
 133   1        char function = data_recieved[3];
 134   1      
 135   1        if (flag == 0x01 || flag == 0x02)
 136   1          LEDmode = 2;
 137   1        else if (flag == 0x00)
 138   1          LEDmode = 1;
 139   1        else if (flag == 0x03)
 140   1        {
 141   2          LEDmode = 3;
 142   2        }
 143   1      
 144   1        if (flag == 0x03)
 145   1        {
 146   2          interp = 0;
 147   2        }
 148   1      }
 149          void myDisplay_callback()
 150          {
 151   1        char flag = data_recieved[2];
 152   1        char menu_select = data_recieved[3];
 153   1        if (flag == 0x00)
 154   1        {
 155   2          if (menu_select == 0x00)
 156   2            Seg7Print(23, 10, 30, 29, 18, 21, 30, 28);
 157   2          else if (menu_select == 0x01)
 158   2            Seg7Print(42, 13, 40, 29, 40, 38, 29, 42);
 159   2          else if (menu_select == 0x02)
 160   2            Seg7Print(42, 11, 27, 24, 32, 28, 40, 42);
 161   2          else if (menu_select == 0x03)
 162   2            Seg7Print(28, 17, 40, 18, 20, 36, 17, 42);
 163   2          else if (menu_select == 0x04)
 164   2            Seg7Print(42, 14, 36, 27, 29, 17, 42, 42);
 165   2        }
 166   1        else if (flag == 0x01)
 167   1          Seg7Print(23, 10, 30, 29, 18, 21, 30, 28);
 168   1        else if (flag == 0x03)
 169   1          Seg7Print(16, 14, 29, 42, 13, 10, 35, 14);
 170   1        else if (flag == 0x10)
 171   1        {
 172   2          if (menu_select == 0x01)
 173   2            Seg7Print(42, 12, 21, 24, 12, 20, 42, 42);
 174   2          else if (menu_select == 0x02)
 175   2            Seg7Print(42, 42, 12, 10, 22, 42, 42, 42);
 176   2          else if (menu_select == 0x03)
 177   2            Seg7Print(42, 42, 29, 14, 22, 25, 42, 42);
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 4   

 178   2          else if (menu_select == 0x04)
 179   2            Seg7Print(42, 42, 22, 10, 16, 42, 42, 42);
 180   2          else if (menu_select == 0x05)
 181   2            Seg7Print(42, 22, 30, 28, 18, 12, 42, 42);
 182   2          else if (menu_select == 0x06)
 183   2            Seg7Print(42, 42, 11, 24, 22, 11, 42, 42);
 184   2        }
 185   1        else if (flag == 0x11)
 186   1        {
 187   2          unsigned char dispData[8]; // 数码管显示数据数组
 188   2      
 189   2          // 读取当前时间
 190   2          currentTime = RTC_Read();
 191   2      
 192   2          // 解析时分秒为数码管显示格式（时时―分分―秒秒）
 193   2          dispData[0] = (currentTime.hour >> 4) & 0x0F; // 时高位
 194   2          dispData[1] = currentTime.hour & 0x0F;      // 时低位
 195   2          dispData[2] = 42;               // '-'分隔符
 196   2          dispData[3] = (currentTime.minute >> 4) & 0x0F; // 分高位
 197   2          dispData[4] = currentTime.minute & 0x0F;    // 分低位
 198   2          dispData[5] = 42;               // '-'分隔符
 199   2          dispData[6] = (currentTime.second >> 4) & 0x0F; // 秒高位
 200   2          dispData[7] = currentTime.second & 0x0F;    // 秒低位
 201   2      
 202   2          uart_data[0] = dispData[0];
 203   2          uart_data[1] = dispData[1];
 204   2          uart_data[2] = dispData[3];
 205   2          uart_data[3] = dispData[4];
 206   2          uart_data[4] = dispData[6];
 207   2          uart_data[5] = dispData[7];
 208   2          uart_data[6] = 0xaa;
 209   2          uart_data[7] = (currentTime.year >> 4) & 0x0F;
 210   2          uart_data[8] = currentTime.year & 0x0F;
 211   2          uart_data[9] = (currentTime.week >> 4) & 0x0F;
 212   2          uart_data[10] = currentTime.week & 0x0F;
 213   2          uart_data[11] = (currentTime.month >> 4) & 0x0F;
 214   2          uart_data[12] = currentTime.month & 0x0F;
 215   2          uart_data[13] = (currentTime.day >> 4) & 0x0F;
 216   2          uart_data[14] = currentTime.day & 0x0F;
 217   2          Uart2Print(uart_data, 15);
 218   2          // 输出到数码管（8位显示）
 219   2          Seg7Print(dispData[0], dispData[1], dispData[2], dispData[3],
 220   2                dispData[4], dispData[5], dispData[6], dispData[7]);
 221   2          LedPrint(0xFF);
 222   2        }
 223   1        else if (flag == 0x13)
 224   1        {
 225   2          int lux = GetADC().Rop;
 226   2          int rt = GetADC().Rt;
 227   2      
 228   2          uart_data[0] = rt / 100 % 10;
 229   2          uart_data[1] = rt / 10 % 10;
 230   2          uart_data[2] = rt % 10;
 231   2          uart_data[3] = lux / 100 % 10;
 232   2          uart_data[4] = lux / 10 % 10;
 233   2          uart_data[5] = lux % 10;
 234   2          uart_data[6] = 0xaa;
 235   2          Uart2Print(uart_data, 7);
 236   2          Seg7Print(rt / 100 % 10, rt / 10 % 10, rt % 10, 0, 0, lux / 100 % 10, lux / 10 % 10, lux % 10);
 237   2        }
 238   1      }
 239          void myKey_callback()
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 5   

 240          {
 241   1        if (GetKeyAct(enumKey1) == enumKeyPress)
 242   1        {
 243   2          SetPlayerMode(enumModePlay);
 244   2          uart_data[0] = 0xaa;
 245   2          uart_data[1] = 0x55;
 246   2          uart_data[2] = 0x04;
 247   2          Uart2Print(uart_data, 3);
 248   2        }
 249   1        if (GetKeyAct(enumKey2) == enumKeyPress)
 250   1        {
 251   2          SetPlayerMode(enumModePause);
 252   2          uart_data[0] = 0xaa;
 253   2          uart_data[1] = 0x55;
 254   2          uart_data[2] = 0x05;
 255   2          Uart2Print(uart_data, 3);
 256   2        }
 257   1      }
 258          void beep_check()
 259          {
 260   1        if (GetBeepStatus() == enumBeepFree && interp == 0)
 261   1        {
 262   2          a += 1;
 263   2        }
 264   1      
 265   1        if (a > 4)
 266   1        {
 267   2          a = 0;
 268   2        }
 269   1      
 270   1        if (interp == 0 && a == 1)
 271   1        {
 272   2          SetBeep(523, 17);
 273   2        }
 274   1        else if (interp == 0 && a == 2)
 275   1        {
 276   2          SetBeep(587, 17);
 277   2        }
 278   1        else if (interp == 0 && a == 3)
 279   1        {
 280   2          SetBeep(659, 17);
 281   2        }
 282   1        else if (interp == 0 && a == 4)
 283   1        {
 284   2          SetBeep(784, 80);
 285   2          interp = 1;
 286   2        }
 287   1      }
 288          void myLED_callback()
 289          {
 290   1        // 初始界面
 291   1        if (LEDmode == 1 && LEDchange == 1)
 292   1        {
 293   2          LedPrint(0x55);
 294   2        }
 295   1        else if (LEDmode == 1 && LEDchange == -1)
 296   1        {
 297   2          LedPrint(0xaa);
 298   2        }
 299   1        else if (LEDmode == 2)
 300   1        {
 301   2          LedPrint(led_val);
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 6   

 302   2        }
 303   1        else if (LEDmode == 3 && LEDchange == 1)
 304   1        {
 305   2          LedPrint(0xFF);
 306   2        }
 307   1        else if (LEDmode == 3 && LEDchange == -1)
 308   1        {
 309   2          LedPrint(0x00);
 310   2        }
 311   1        LEDchange *= -1;
 312   1      
 313   1        // 流水灯
 314   1        if (led_val < 0x80 && led_flow_reverse == 1)
 315   1        {
 316   2          led_val = led_val << 1;
 317   2        }
 318   1        else if (led_val > 0x01 && led_flow_reverse == -1)
 319   1        {
 320   2          led_val = led_val >> 1;
 321   2        }
 322   1        else if (led_val == 0x80 || led_val == 0x01)
 323   1        {
 324   2          led_flow_reverse *= -1;
 325   2        }
 326   1      }
 327          void my10mS_callback()
 328          {
 329   1        // Beep轮询
 330   1        beep_check();
 331   1      }
 332          void myVib_callback()
 333          {
 334   1        char k = GetVibAct();
 335   1        if (k == enumVibQuake)
 336   1        {
 337   2          uart_data[0] = 0xaa;
 338   2          uart_data[1] = 0x55;
 339   2          uart_data[2] = 0x01;
 340   2          Uart2Print(uart_data, 3);
 341   2        }
 342   1      }
 343          void myHall_callback()
 344          {
 345   1        char k = GetHallAct();
 346   1        if (k == enumHallGetClose)
 347   1        {
 348   2          uart_data[0] = 0xaa;
 349   2          uart_data[1] = 0x55;
 350   2          uart_data[2] = 0x02;
 351   2          Uart2Print(uart_data, 3);
 352   2          // Beep
 353   2          interp = 0;
 354   2        }
 355   1        else if (k == enumHallGetAway)
 356   1        {
 357   2          uart_data[0] = 0xaa;
 358   2          uart_data[1] = 0x55;
 359   2          uart_data[2] = 0x03;
 360   2          Uart2Print(uart_data, 3);
 361   2        }
 362   1      }
 363          
C51 COMPILER V9.51   MAIN                                                                  09/19/2025 10:17:03 PAGE 7   

 364          void main()
 365          {
 366   1        Uart2Init(115200, Uart2UsedforEXT);
 367   1        displayerInit();
*** WARNING C206 IN LINE 367 OF main.c: 'displayerInit': missing function-prototype
 368   1        keyInit();
*** WARNING C206 IN LINE 368 OF main.c: 'keyInit': missing function-prototype
 369   1        VibInit();
 370   1        MusicPlayerInit();
 371   1        BeepInit();
 372   1        HallInit();
 373   1        SetDisplayerArea(0, 7);
 374   1        DS1302Init(initTime);
 375   1        AdcInit(ADCexpEXT);
 376   1      
 377   1        SetUart2Rxd(data_recieved, RECEIVE_LEN, matched_data, 2);
 378   1      
 379   1        SetMusic(90, 0xFA, pokemon_get_DAZE, sizeof(pokemon_get_DAZE), enumMscDrvLed);
 380   1      
 381   1        SetEventCallBack(enumEventHall, myHall_callback);
 382   1        SetEventCallBack(enumEventVib, myVib_callback);
 383   1        SetEventCallBack(enumEventKey, myKey_callback);
 384   1        SetEventCallBack(enumEventUart2Rxd, myUart2_callback);
 385   1        SetEventCallBack(enumEventSys1S, myDisplay_callback);
 386   1        SetEventCallBack(enumEventSys100mS, myLED_callback);
 387   1        SetEventCallBack(enumEventSys10mS, my10mS_callback);
 388   1      
 389   1        MySTC_Init();
 390   1        while (1)
 391   1        {
 392   2          MySTC_OS();
 393   2        }
 394   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1587    ----
   CONSTANT SIZE    =    338    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     54      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
